//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from c:\Users\amaur\Documents\Compiladores I\PruebasProyecto\Prueba1\PruebaANTLR\TINY.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

namespace CompilerCLI.ANTLR4Files
{



	[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
	[System.CLSCompliant(false)]
	public partial class TINYParser : Parser
	{
		protected static DFA[] decisionToDFA;
		protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
		public const int
			T__0 = 1, If = 2, Else = 3, Fi = 4, Do = 5, Until = 6, While = 7, Read = 8, Write = 9, Float = 10,
			INT = 11, Bool = 12, NOT = 13, Or = 14, And = 15, Equals = 16, NEquals = 17, GTEquals = 18,
			LTEquals = 19, Pow = 20, Excl = 21, GT = 22, LT = 23, Add = 24, Subtract = 25, Multiply = 26,
			Divide = 27, Modulus = 28, OBrace = 29, CBrace = 30, OBracket = 31, CBracket = 32,
			OParen = 33, CParen = 34, SColon = 35, Assign = 36, Comma = 37, QMark = 38, Colon = 39,
			Tipo = 40, Number = 41, Identifier = 42, String = 43, Comment = 44, Space = 45;
		public const int
			RULE_program = 0;
		public static readonly string[] ruleNames = {
		"program"
	};

		private static readonly string[] _LiteralNames = {
		null, "'program'", "'if'", "'else'", "'fi'", "'do'", "'until'", "'while'",
		"'read'", "'write'", "'float'", "'int'", "'bool'", "'not'", "'or'", "'and'",
		"'=='", "'!='", "'>='", "'<='", "'^'", "'!'", "'>'", "'<'", "'+'", "'-'",
		"'*'", "'/'", "'%'", "'{'", "'}'", "'['", "']'", "'('", "')'", "';'",
		"'='", "','", "'?'", "':'"
	};
		private static readonly string[] _SymbolicNames = {
		null, null, "If", "Else", "Fi", "Do", "Until", "While", "Read", "Write",
		"Float", "INT", "Bool", "NOT", "Or", "And", "Equals", "NEquals", "GTEquals",
		"LTEquals", "Pow", "Excl", "GT", "LT", "Add", "Subtract", "Multiply",
		"Divide", "Modulus", "OBrace", "CBrace", "OBracket", "CBracket", "OParen",
		"CParen", "SColon", "Assign", "Comma", "QMark", "Colon", "Tipo", "Number",
		"Identifier", "String", "Comment", "Space"
	};
		public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

		[NotNull]
		public override IVocabulary Vocabulary
		{
			get
			{
				return DefaultVocabulary;
			}
		}

		public override string GrammarFileName { get { return "TINY.g4"; } }

		public override string[] RuleNames { get { return ruleNames; } }

		public override string SerializedAtn { get { return new string(_serializedATN); } }

		static TINYParser()
		{
			decisionToDFA = new DFA[_ATN.NumberOfDecisions];
			for (int i = 0; i < _ATN.NumberOfDecisions; i++)
			{
				decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
			}
		}

		public TINYParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public TINYParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
		{
			Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
		}

		public partial class ProgramContext : ParserRuleContext
		{
			public ProgramContext(ParserRuleContext parent, int invokingState)
				: base(parent, invokingState)
			{
			}
			public override int RuleIndex { get { return RULE_program; } }

			public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
			{
				ITINYVisitor<TResult> typedVisitor = visitor as ITINYVisitor<TResult>;
				if (typedVisitor != null) return typedVisitor.VisitProgram(this);
				else return visitor.VisitChildren(this);
			}
		}

		[RuleVersion(0)]
		public ProgramContext program()
		{
			ProgramContext _localctx = new ProgramContext(Context, State);
			EnterRule(_localctx, 0, RULE_program);
			try
			{
				EnterOuterAlt(_localctx, 1);
				{
					State = 2; Match(T__0);
				}
			}
			catch (RecognitionException re)
			{
				_localctx.exception = re;
				ErrorHandler.ReportError(this, re);
				ErrorHandler.Recover(this, re);
			}
			finally
			{
				ExitRule();
			}
			return _localctx;
		}

		private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786',
		'\x5964', '\x3', '/', '\a', '\x4', '\x2', '\t', '\x2', '\x3', '\x2', '\x3',
		'\x2', '\x3', '\x2', '\x2', '\x2', '\x3', '\x2', '\x2', '\x2', '\x2',
		'\x5', '\x2', '\x4', '\x3', '\x2', '\x2', '\x2', '\x4', '\x5', '\a', '\x3',
		'\x2', '\x2', '\x5', '\x3', '\x3', '\x2', '\x2', '\x2', '\x2',
	};

		public static readonly ATN _ATN =
			new ATNDeserializer().Deserialize(_serializedATN);


	}

}